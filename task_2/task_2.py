
# Временная сложность:
# - Инициализация: O(d * n) — чтение признаков и вычисление начальной релевантности.
# - Обработка запросов:
#     * Тип 1 ("1 k"): O(d log d) — сортировка всех объектов по релевантности.
#     * Тип 2 ("2 i j v"): O(1) — обновление одного признака и пересчёт релевантности.
# - В худшем случае (q запросов типа 1): O(q * d log d).
# - При ограничениях (d, q ≤ 100 000) и небольшом q это приемлемо.
#
# Пространственная сложность:
# - Хранение признаков: O(d * n)
# - Хранение релевантности: O(d)
# - Вспомогательный массив для сортировки: O(d)
# - Общая память: O(d * n), что укладывается в лимиты.

import sys

def main():
    # Этап 1: чтение параметров формулы
    n = int(input())  # количество признаков у каждого объекта
    a = list(map(int, input().split()))  # коэффициенты a[0] ... a[n-1]

    # Этап 2: чтение объектов и вычисление начальной релевантности
    d = int(input())  # количество объектов
    features = []      # features[i] — список признаков i-го объекта (0-based)
    relevance = [0] * d  # relevance[i] — текущая релевантность i-го объекта

    for i in range(d):
        f_i = list(map(int, input().split()))
        features.append(f_i)
        # Вычисляем релевантность: sum(a[j] * f_i[j] for all j)
        relevance[i] = sum(a[j] * f_i[j] for j in range(n))

    # Этап 3: чтение количества запросов
    q = int(input())  # число запросов

    # Этап 4: обработка каждого запроса
    for _ in range(q):
        query = list(map(int, input().split()))
        
        if query[0] == 1:
            # Запрос типа 1: вывести k самых релевантных объектов
            k = query[1]
            # Создаём список пар (релевантность, номер_объекта_с_1)
            indexed = [(relevance[i], i + 1) for i in range(d)]
            # Сортируем по убыванию релевантности
            indexed.sort(key=lambda x: x[0], reverse=True)
            # Извлекаем первые k номеров
            result = [str(obj[1]) for obj in indexed[:k]]
            print(' '.join(result))
            
        elif query[0] == 2:
            # Запрос типа 2: обновить признак объекта
            obj_num = query[1]      # номер объекта (1-based)
            feat_num = query[2]     # номер признака (1-based)
            new_val = query[3]      # новое значение признака
            
            # Переводим в 0-based индексы
            i = obj_num - 1
            j = feat_num - 1
            
            # Сохраняем старое значение
            old_val = features[i][j]
            # Обновляем признак
            features[i][j] = new_val
            # Пересчитываем релевантность с учётом изменения
            relevance[i] += a[j] * (new_val - old_val)
            # Ничего не выводим

if __name__ == "__main__":
    main()